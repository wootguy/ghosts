#pragma once
#pragma pack(push,1)

// This code was automatically generated by the ApiGenerator plugin.
// Prefer updating the generator code instead of editing this directly.
// "u[]" variables are unknown data.

// Example entity: item_inventory
class CItemInventory : public CBaseEntity {
public:
    byte u11_0[144];
    EHandle m_hHolder; // The monster or player holding this item.
    vec3_t m_vecSpawnOrigin; // Spawn-time origin.
    vec3_t m_vecSpawnAngles; // Spawn-time angles.
    int m_iMoveType; // Spawn-time move type.
    string_t m_szItemName; // Item name referred to by triggers, doesn't need to be unique -- remember the targetname refers to the entity itself only.
    string_t m_szItemGroup; // Group name referred to by triggers.
    byte u11_1[4];
    string_t m_szDescription; // Friendly item description for client-side UI.
    byte u11_2[4];
    int m_iCollectLimit; // How many times the item can be picked up, destroyed when limit is reached (0 = infinite).
    byte u11_3[4];
    float m_flWeight; // How heavy the item is (0-100),<br>holders can hold multiple items up to a total weight 100, think of this as KG if you like (though what person can carry 100KG!?).
    bool m_fHiddenWhenCarried; // Model is hidden while it is being carried.
    byte u11_4[3];
    int m_iIdleSkin; // Model skin while IDLE (not carried).
    int m_iIdleBody; // Model body while IDLE.
    string_t m_szIdleSequenceName; // Model sequence name while IDLE.
    int m_iIdleSequence; // Model sequence number while IDLE.
    int m_iCarriedSkin; // Model skin while CARRIED.
    int m_iCarriedBody; // Model body while CARRIED.
    string_t m_szCarriedSequenceName; // Model sequence name while CARRIED.
    int m_iCarriedSequence; // Model sequence number while CARRIED.
    string_t m_szAllowedTargetNames; // CBaseEntity target name filters
    string_t m_szAllowedClassNames; // CBaseEntity class name filters
    string_t m_szAllowedTeams; // Team filters
    int m_iAllowedNpcClassify; // NPC classification filter
    string_t m_szRequiresItemName; // Require these item(s)
    string_t m_szRequiresItemGroup; // Require an item from these group(s)
    int m_iRequiresItemGroupNum; // Number of item(s) from the required group(s) required (0 = all)
    string_t m_szItemNameMoved; // These item(s) must have moved
    string_t m_szCantHaveItemName; // Must not have these item(s)
    string_t m_szCantHaveItemGroup; // Must not have an item in these group(s)
    int m_iCantHaveItemGroupNum; // Number of item(s) from the can't have group(s) (0 = all)
    string_t m_szItemNameNotMoved; // These item(s) must NOT have moved
    float m_flMaximumHoldTime; // Limit to how long this item can be held for, forcibly dropped after (0 = no limit)
    byte u11_5[4];
    float m_flWearOutTime; // Perform a trigger prior to this item being forcibly dropped (0 = none)
    byte u11_6[2];
    bool m_fCanBeDropped; // Holder is allowed to drop this item by choice
    byte u11_7[1];
    float m_flReturnTime; // How long this item returns to its' original location when dropped (-1 = never, 0 = instant)
    bool m_fDelayedRespawn; // Delayed respawn on return (like with weapons/ammo/pickups)
    bool m_fKeepOnDeath; // Holder still has the item after dying (i.e. so they can keep it while being revived)
    bool m_fKeepOnRespawn; // Holder still has the item after respawning (only applies to players -- re-equip NPC's manually)
    byte u11_8[1];
    string_t m_szTriggerOnCollectSelf; // On successful collection (for collector)
    string_t m_szTriggerOnCollectTeam; // On successful collection (for collector's team)
    string_t m_szTriggerOnCollectOther; // On successful collection (for everyone else)
    string_t m_szTriggerOnCantCollectSelf; // On failed collection (for collector)
    string_t m_szTriggerOnCantCollectTeam; // On failed collection (for collector's team)
    string_t m_szTriggerOnCantCollectOther; // On failed collection (for everyone else)
    string_t m_szTriggerOnDropSelf; // On successful drop (for collector)
    string_t m_szTriggerOnDropTeam; // On successful drop (for collector's team)
    string_t m_szTriggerOnDropOther; // On successful drop (for everyone else)
    string_t m_szTriggerOnCantDropSelf; // On failed drop (for collector)
    string_t m_szTriggerOnCantDropTeam; // On failed drop (for collector's team)
    string_t m_szTriggerOnCantDropOther; // On failed drop (for everyone else)
    byte u11_9[24];
    string_t m_szTriggerOnUseSelf; // On use by trigger (for collector)
    string_t m_szTriggerOnUseTeam; // On use by trigger (for collector's team)
    string_t m_szTriggerOnUseOther; // On use by trigger (for everyone else)
    string_t m_szTriggerOnWearingOutSelf; // On wearing out (for collector)
    string_t m_szTriggerOnWearingOutTeam; // On wearing out (for collector's team)
    string_t m_szTriggerOnWearingOutOther; // On wearing out (for everyone else)
    string_t m_szTriggerOnReturnSelf; // On return (for collector)
    string_t m_szTriggerOnReturnTeam; // On return (for collector's team)
    string_t m_szTriggerOnReturnOther; // On return (for everyone else)
    string_t m_szTriggerOnMaterialise; // On materialise after return
    string_t m_szTriggerOnDestroy; // On destroy
    byte u11_10[1];
    bool m_fEffectsPermanent; // Holder keeps effects after dropping the item
    byte u11_11[2];
    vec3_t m_vecEffectGlowColor; // Holder has a glow shell
    bool m_fEffectBlockWeapons; // Holder can't use weapons
    bool m_fEffectInvulnerable; // Holder is invulnerable (god mode)
    bool m_fEffectInvisible; // Holder is invisible (render + non-targetable)
    bool m_fEffectNonSolid; // Holder is non-solid
    float m_flEffectRespiration; // Extra/less breathing time underwater in seconds
    float m_flEffectGravity; // Gravity modifier (%)
    float m_flEffectFriction; // Movement friction modifier (%)
    float m_flEffectSpeed; // Movement speed modifier (%)
    float m_flEffectDamage; // Damage modifier (%)
    int m_iCollectCount; // Number of times the item has been collected
    byte u11_12[4];
    float m_flTouchedTime; // Time the item was last touched
    float m_flCollectTime; // Time the item was last collected
    float m_flDropTime; // Time the item was last dropped
    byte u11_13[4];
    bool m_fRemovedByForced; // Item was just removed by force
};
#pragma pack(pop)
